<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title></title>
</head>
<body>
    <script>
        //工厂模式
        // 创建对象交给一个工厂方法来实现，可以传递参数，但主要缺点是无法识别对象类型，因为创建对象都是使用Object的原生构造函数来完成的。
        //function createPerson(name, age, job) {
        //    var o = new Object();
        //    o.name = name;
        //    o.age = age;
        //    o.job = job;
        //    o.getName = function () {
        //        return this.name;
        //    }
        //    return o;//使用return返回生成的对象实例
        //}
        //var person = createPerson('Jack', 19, 'SoftWare Engineer');
        //var bigPerson = createPerson("Tom", 22, "COO");
        //alert(person.name);
        //alert(bigPerson.name);
        //alert(person instanceof Object);//true;
        //alert(person.constructor === bigPerson.constructor);//ture;


        //构造函数模式
        //创建多个实例时，会重复调用new Function();创建多个函数实例，这些函数实例还不是一个作用域中，当然这一般不会有错，但这会造成内存浪费。
        //当然，可以在函数中定义一个getName = getName的引用，而getName函数在Person外定义，这样可以解决重复创建函数实例问题，但在效果上并没有起到封装的效果
        //function Person(name, age, job) {

        //    this.name = name;

        //    this.age = age;

        //    this.job = job;

        //    this.getName = function () {

        //        return this.name;

        //    };
        //}
        //var person1 = new Person('Jack', 19, 'SoftWare Engineer');

        //var person2 = new Person('Liye', 23, 'Mechanical Engineer');

        //alert(person1.name);

        //alert(person2.name);

        //alert(person1 instanceof Person);//true;

        //alert(person2 instanceof Person);//true;

        //alert(person1 instanceof Object);//true;

        //alert(person1.constructor === person2.constructor);//ture;

        // 创建多个实例时，会重复调用new Function();创建多个函数实例，这些函数实例还不是一个作用域中，当然这一般不会有错，但这会造成内存浪费。    
        //function Person(name,age,job){

        //    this.name = name;

        //    this.age = age;

        //    this.job = job;

        //    this.getName = new function () {//改写后效果与原代码相同，不过是为了方便理解

        //        return this.name;

        //    }

        //}

        //可以在函数中定义一个getName = getName的引用，而getName函数在Person外定义，这样可以解决重复创建函数实例问题，但在效果上并没有起到封装的效果
        //function Person(name, age, job) {

        //    this.name = name;

        //    this.age = age;

        //    this.job = job;

        //    this.getName = getName;

        //}

        //function getName() {//到处是代码，看着乱！！

        //    return this.name;

        //}

        //原型模式
        // 原型模式的缺点，它省略了为构造函数传递初始化参数，这在一定程序带来不便；
        //另外，最主要是当对象的属性是引用类型时，它的值是不变的，总是引用同一个外部对象，所有实例对该对象的操作都会其它实例
        //function Person() {
        //}
        //Person.prototype.name = 'Jack';//使用原型来添加属性
        //Person.prototype.age = 29;
        //Person.prototype.getName = function () {
        //    return this.name;
        //}
        //Person.prototype.items = ["food","water"];
        //var person1 = new Person();
        //alert(person1.name);
        //person1.name = "Tom";
        //person1.items.push("gun");
        //alert(person1.getName());//Jack
        //var person2 = new Person();
        //alert(person2.getName());
        //alert(person2.items);

        //组合构造函数及原型模式
        //目前最为常用的定义类型方式，是组合构造函数模式与原型模式。
        //构造函数模式用于定义实例的属性，而原型模式用于定义方法和共享的属性。
        //结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方方法的引用，最大限度的节约内存。
        //此外，组合模式还支持向构造函数传递参数，可谓是集两家之所长。
        //function Person(name, age, job) {
        //    this.name = name;
        //    this.age = age;
        //    this.job = job;
        //    this.lessons = ['Math', 'Physics'];
        //}
        //Person.prototype = {
        //    constructor: Person,//原型字面量方式会将对象的constructor变为Object，此外强制指回Person
        //    getName: function () {
        //        return this.name;
        //    }
        //}
        //var person1 = new Person('Jack', 19, 'SoftWare Engneer');
        //person1.lessons.push('Biology');
        //var person2 = new Person('Lily', 39, 'Mechanical Engneer');
        //alert(person1.lessons);//Math,Physics,Biology
        //alert(person2.lessons);//Math,Physics
        //alert(person1.getName());
        //alert(person2.getName());
        //alert(person1.getName === person2.getName);//true,//共享原型中定义方法
        //alert(person1 instanceof Person);



        //动态原型模式
        //组合模式中实例属性与共享方法（由原型定义）是分离的，这与纯面向对象语言不太一致；
        //动态原型模式将所有构造信息都封装在构造函数中，又保持了组合的优点。
        //其原理就是通过判断构造函数的原型中是否已经定义了共享的方法或属性，如果没有则定义，否则不再执行定义过程。
        //该方式只原型上方法或属性只定义一次，且将所有构造过程都封装在构造函数中，对原型所做的修改能立即体现所有实例中
        //function Person(name, age, job) {
        //    this.name = name;
        //    this.age = age;
        //    this.job = job;
        //    this.lessons = ['Math', 'Physics'];
        //    this.getName;
        //    if (typeof this.getName != 'function') {//通过判断实例封装
        //        Person.prototype = {
        //            constructor: Person,//原型字面量方式会将对象的constructor变为Object，此外强制指回Person
        //            getName: function () {
        //                return this.name;
        //            }
        //        }
        //    }
        //}       

        //var person1 = new Person('Jack', 19, 'SoftWare Engneer');
        //person1.lessons.push('Biology');
        //var person2 = new Person('Lily', 39, 'Mechanical Engneer');
        //alert(person1.lessons);//Math,Physics,Biology
        //alert(person2.lessons);//Math,Physics
        //alert(person1.getName === person2.getName);//true,//共享原型中定义方法

        //var a = new Person("Mr.A", 22, "Boss");
        //var b = new Person("Miss.B", 33, "Teacher");

        //alert(a.getName());

        //alert(b.getName());

        //alert(a.getName === b.getName);//true,//共享原型中定义方法
        //alert(a instanceof Person);
    </script>
</body>
</html>
